package main

import (
	"fmt"
	"io/ioutil"
	"math"
	"os"
	"strconv"
	"strings"
	"testing"
)

func TestBuildQuadtree(t *testing.T) {
	type test struct {
		currentUniverse *Universe
		answer          []treeNode
	}
	inputDirectory := "tests/BuildQuadtree/input/"
	outputDirectory := "tests/BuildQuadtree/output/"

	inputFiles := ReadFilesFromDirectory(inputDirectory)
	outputFiles := ReadFilesFromDirectory(outputDirectory)

	//assert that files are non-empty and have the same length
	AssertEqualAndNonzero(len(inputFiles), len(outputFiles))

	//we now will need to create our array of tests
	tests := make([]test, len(inputFiles))

	for i := range inputFiles {
		tests[i].currentUniverse = ReadUniverseFromFile(inputDirectory, inputFiles[i])
		tests[i].answer = ReadTreeFromFile(outputDirectory, outputFiles[i])
	}

	for i, test := range tests {
		outcome := tests[i].currentUniverse.BuildQuadtree()
		CompareResults(&outcome, test.answer, t, i)
	}
}

//CompareResults compares the quadtree generated by our function and the correct answer.
func CompareResults(q *QuadTree, op []treeNode, t *testing.T, k int) {
	// Convert a tree to a list of nodes by using queue
	queue := make(Queue, 0)
	rootT := q.root
	queue.Enqueue(rootT)
	count := 0
	for {
		if count >= len(queue) {
			break
		}
		cn := queue[count]
		// add the children of each node to the queue according to the order in which nodes are put in
		if cn.children == nil {
			count = count + 1
			continue
		} else {
			for i := 0; i < 4; i++ {
				queue.Enqueue(cn.children[i])
			}
		}
		fmt.Println(queue)
		fmt.Println(count)
		count = count + 1
	}

	//Convert Node to treeNode type for comparison
	myfuncOp := make([]treeNode, len(queue))
	for i := range queue {
		myfuncOp[i] = NodeToTreenode(queue[i])
	}
	// Compare length
	if len(myfuncOp) != len(op) {
		t.Errorf("Error! For input dataset %d, your code's output's length is %d, and the correct answer is %d", k, len(myfuncOp), len(op))
	} else {
		// Compare each node
		for i := range myfuncOp {
			fmt.Println("Node", i)
			fmt.Println("your code's output:(IsStarNil, position)", myfuncOp[i].isStarNil, myfuncOp[i].position)
			fmt.Println("The correct answer:(IsStarNil, position)", op[i].isStarNil, op[i].position)
			if CheckEachNode(myfuncOp[i], op[i]) == false {
				t.Errorf("Error for node %d", i)
			}
		}
	}

}

// Check if each node in our tree is equal to the node in correct answer
func CheckEachNode(a, b treeNode) bool {
	if a.isStarNil == b.isStarNil && roundFloat(a.position.x, 2) == roundFloat(b.position.x, 2) && roundFloat(a.position.y, 2) == roundFloat(b.position.y, 2) {
		return true
	} else {
		return false
	}
}

// Put a node into the queue
func (q *Queue) Enqueue(n *Node) {
	newQueue := make(Queue, len(*q)+1)
	for i := range *q {
		newQueue[i] = (*q)[i]
	}
	newQueue[len(*q)] = n
	*q = newQueue //?
}

// Convert Node object to treeNode object
func NodeToTreenode(n *Node) treeNode {
	var newTreenode treeNode
	if n.star == nil {
		newTreenode.isStarNil = 1
	} else if n.children == nil {
		newTreenode.isStarNil = 0
		newTreenode.isChildNil = 1
		newTreenode.position.x = n.star.position.x
		newTreenode.position.y = n.star.position.y
	} else {
		newTreenode.isStarNil = 0
		newTreenode.isChildNil = 0
		newTreenode.position.x = n.star.position.x
		newTreenode.position.y = n.star.position.y
	}
	return newTreenode
}

// ReadTreeFromFile read txt files and convert them into lists of treeNodes objects
func ReadTreeFromFile(directory string, inputFile os.FileInfo) []treeNode {
	fileName := inputFile.Name() //grab file name

	//now, read in the input file
	fileContents, err := ioutil.ReadFile(directory + fileName)
	if err != nil {
		panic(err)
	}

	//first, read lines and split along blank space
	inputLines := strings.Split(strings.TrimSpace(strings.Replace(string(fileContents), "\r\n", "\n", -1)), "\n")
	tree := make([]treeNode, 0)
	for _, inputLine := range inputLines {
		var n treeNode
		currentLine := strings.Split(inputLine, " ")
		n.isChildNil, _ = strconv.Atoi(currentLine[0])
		n.isStarNil, _ = strconv.Atoi(currentLine[1])
		n.position.x, _ = strconv.ParseFloat(currentLine[2], 64)
		n.position.y, _ = strconv.ParseFloat(currentLine[3], 64)
		n.sector.x, _ = strconv.ParseFloat(currentLine[4], 64)
		n.sector.y, _ = strconv.ParseFloat(currentLine[5], 64)
		n.width, _ = strconv.ParseFloat(currentLine[6], 64)
		n.starMass, _ = strconv.ParseFloat(currentLine[7], 64)
		tree = append(tree, n)
	}

	return tree

}

// ReadUniverseFromFile read txt files and convert them into lists of universe objects
func ReadUniverseFromFile(directory string, inputFile os.FileInfo) *Universe {
	fileName := inputFile.Name() //grab file name

	//now, read in the input file
	fileContents, err := ioutil.ReadFile(directory + fileName)
	if err != nil {
		panic(err)
	}

	//first, read lines and split along blank space
	inputLines := strings.Split(strings.TrimSpace(strings.Replace(string(fileContents), "\r\n", "\n", -1)), "\n")

	starIdex := -1
	var u Universe
	stars := make([]*Star, 0)
	for _, inputLine := range inputLines {
		if starIdex == -1 {
			currentLine := strings.Split(inputLine, " ")
			u.width, err = strconv.ParseFloat(currentLine[0], 64)
			starIdex = starIdex + 1
			continue
		}
		var s Star
		//read out the current line
		currentLine := strings.Split(inputLine, " ")
		//currentLine has two strings corresponding to the key and value
		s.position.x, _ = strconv.ParseFloat(currentLine[0], 64)
		s.position.y, _ = strconv.ParseFloat(currentLine[1], 64)
		s.mass, _ = strconv.ParseFloat(currentLine[2], 64)
		stars = append(stars, &s)
	}
	u.stars = stars

	return &u
}

func ReadFilesFromDirectory(directory string) []os.FileInfo {
	dirContents, err := ioutil.ReadDir(directory)
	if err != nil {
		panic("Error reading directory: " + directory)
	}

	return dirContents
}

func AssertEqualAndNonzero(length0, length1 int) {
	if length0 == 0 {
		panic("No files present in input directory.")
	}
	if length1 == 0 {
		panic("No files present in output directory.")
	}
	if length0 != length1 {
		panic("Number of files in directories doesn't match.")
	}
}

func roundFloat(val float64, precision uint) float64 {
	ratio := math.Pow(10, float64(precision))
	return math.Round(val*ratio) / ratio
}
